---
# Tekton Task that:
#  1) Uses quay.io/testing-farm/cli to submit a request referencing your Git repo + tmt plan.
#  2) Polls Testing Farm for completion (pass/fail) within a timeout.
#  3) Exits non-zero to fail the pipeline on test failure/timeouts.

apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: testing-farm-request
spec:
  description: >
    Receive image in IMAGE_REF and submit a
    Testing Farm request that will run it as a privileged container.

  params:
    - name: TF_COMPOSE
      type: string
      default: RHEL-9
    - name: TF_ARCH
      type: string
      default: x86_64
    - name: TF_GIT_URL
      type: string
    - name: TF_GIT_REF
      type: string
      default: main
    - name: TF_PLAN
      type: string
      default: /plans/run-root-image
    - name: TF_TIMEOUT_MIN
      type: string
      default: "120"
    - name: TF_TMT_ENV
      type: string
      default: ""

  steps:
    - name: request-and-wait
      # Official small container image with the Testing Farm CLI preinstalled.
      # See docs: https://docs.testing-farm.io/... (referenced in the answer)
      image: quay.io/testing-farm/cli:latest
      env:
        # Provide the API token via a Kubernetes Secret:
        #   kubectl -n <ns> create secret generic testing-farm-api-token --from-literal=token='<TOKEN>'
        - name: TESTING_FARM_API_TOKEN
          valueFrom:
            secretKeyRef:
              name: testing-farm-api-token
              key: token
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        echo ">> IMAGE_REF: ${IMAGE_REF}"
        echo ">> Submitting Testing Farm request"
        TMT_ENV_ARGS=()
        if [[ -n "$(params.TF_TMT_ENV)" ]]; then
          # Space-separated "K=V K2=V2" propagated to the plan environment.
          TMT_ENV_ARGS=(--tmt-environment "$(params.TF_TMT_ENV)")
        fi

        # Submit request and capture JSON response
        REQ_JSON=$(testing-farm request \
          --compose "$(params.TF_COMPOSE)" \
          --arch "$(params.TF_ARCH)" \
          --git-url "$(params.TF_GIT_URL)" \
          --git-ref "$(params.TF_GIT_REF)" \
          --plan "$(params.TF_PLAN)" \
          --timeout "$(params.TF_TIMEOUT_MIN)" \
          "${TMT_ENV_ARGS[@]}" \
          --format json)

        # Extract request id (schema may vary slightly; try common fields)
        REQ_ID=$(echo "$REQ_JSON" | jq -r '.id // .request.id // empty')
        if [[ -z "${REQ_ID:-}" ]]; then
          echo "ERROR: Unable to extract Testing Farm request id"
          echo "$REQ_JSON"
          exit 2
        fi
        echo ">> Request ID: $REQ_ID"

        echo ">> Waiting for completion (timeout: $(params.TF_TIMEOUT_MIN) min)"
        TIMEOUT_SECONDS=$(( ( $(params.TF_TIMEOUT_MIN) + 10 ) * 60 ))
        DEADLINE=$(( $(date +%s) + TIMEOUT_SECONDS ))

        # Poll every 30s; if CLI adds a 'watch' subcommand in your version,
        # you can replace the loop with it.
        while true; do
          OUT=$(testing-farm list --id "$REQ_ID" --format json || true)
          STATE=$(echo "$OUT" | jq -r '.state // .request.state // empty')
          RESULT=$(echo "$OUT" | jq -r '.result.overall // .result // empty')

          echo "Current: state=${STATE:-?} result=${RESULT:-?}"

          if [[ "$STATE" == "complete" ]]; then
            if [[ "$RESULT" == "passed" ]]; then
              echo ">> PASSED"
              exit 0
            else
              echo ">> FAILED (result=${RESULT:-unknown})"
              testing-farm list --id "$REQ_ID" --format text || true
              exit 1
            fi
          fi

          if (( $(date +%s) > DEADLINE )); then
            echo ">> TIMEOUT after $(params.TF_TIMEOUT_MIN) minutes"
            testing-farm list --id "$REQ_ID" --format text || true
            exit 3
          fi

          sleep 30
        done
