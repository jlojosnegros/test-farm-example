---
# Tekton Task that:
#  1) Uses quay.io/testing-farm/cli to submit a request referencing your Git repo + tmt plan.
#  2) Polls Testing Farm for completion (pass/fail) within a timeout.
#  3) Exits non-zero to fail the pipeline on test failure/timeouts.

apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: testing-farm-request
spec:
  description: >
    Receive image in IMAGE_REF and submit a
    Testing Farm request that will run it as a privileged container.

  params:
    - name: TF_COMPOSE
      type: string
      default: RHEL-9
    - name: TF_ARCH
      type: string
      default: x86_64
    - name: TF_GIT_URL
      type: string
    - name: TF_GIT_REF
      type: string
      default: main
    - name: TF_PATH
      type: string
      default: "."
      description: Path to tmt metadata tree root (relative to git repo root)
    - name: TF_PLAN
      type: string
      default: /plans/run-root-image
    - name: TF_TIMEOUT_MIN
      type: string
      default: "120"
    - name: TF_TEST_ENV
      type: string
      default: ""
      description: Variables to pass to test environment (space-separated K=V pairs)
    - name: TF_TMT_ENV
      type: string
      default: ""
      description: Variables to pass to tmt process for report plugins (space-separated K=V pairs)
    - name: IMAGE_REF
      type: string
      description: Container image pullspec to run on Testing Farm VM
    - name: REGISTRY_USER
      type: string
      default: ""
      description: Username for private container registry (optional)
    - name: REGISTRY_PASSWORD
      type: string
      default: ""
      description: Password or token for private container registry (optional)

  results:
    - name: TEST_OUTPUT
      description: Tekton task test output in JSON format with detailed per-binary metrics
    - name: ARTIFACTS_URL
      description: URL to Testing Farm artifacts
    - name: REQUEST_ID
      description: Testing Farm request ID for debugging
    - name: TEST_SUMMARY
      description: Detailed test summary with per-binary breakdown and failed test names
    - name: TEST_LOG_URL
      description: Direct URL to the complete test output log

  steps:
    - name: request-and-wait
      # Official small container image with the Testing Farm CLI preinstalled.
      # See docs: https://docs.testing-farm.io/... (referenced in the answer)
      image: quay.io/testing-farm/cli:latest
      env:
        # Provide the API token via a Kubernetes Secret:
        #   kubectl -n <ns> create secret generic testing-farm-api-token --from-literal=token='<TOKEN>'
        - name: TESTING_FARM_API_TOKEN
          valueFrom:
            secretKeyRef:
              name: testing-farm-api-token
              key: token
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        echo ">> IMAGE_REF: $(params.IMAGE_REF)"
        echo ">> Submitting Testing Farm request"

        # Build array of --environment arguments for test environment variables.
        # Always pass IMAGE_REF, plus any user-specified variables from TF_TEST_ENV.
        TEST_ENV_ARGS=( --environment "IMAGE_REF=$(params.IMAGE_REF)" )

        # Add registry credentials if provided
        if [[ -n "$(params.REGISTRY_USER)" ]] && [[ -n "$(params.REGISTRY_PASSWORD)" ]]; then
          TEST_ENV_ARGS+=( --environment "REGISTRY_USER=$(params.REGISTRY_USER)" )
          TEST_ENV_ARGS+=( --environment "REGISTRY_PASSWORD=$(params.REGISTRY_PASSWORD)" )
        fi

        if [[ -n "$(params.TF_TEST_ENV)" ]]; then
          # Space-separated "K=V K2=V2" propagated to the test environment.
          TEST_ENV_ARGS+=( --environment "$(params.TF_TEST_ENV)" )
        fi

        # Build array of --tmt-environment arguments for tmt process configuration.
        # Used for configuring tmt report plugins (reportportal, polarion, etc).
        TMT_ENV_ARGS=()
        if [[ -n "$(params.TF_TMT_ENV)" ]]; then
          TMT_ENV_ARGS+=( --tmt-environment "$(params.TF_TMT_ENV)" )
        fi

        # Display the exact command that will be executed
        echo ""
        echo "==> Executing command:"
        echo "testing-farm request \\"
        echo "  --compose \"$(params.TF_COMPOSE)\" \\"
        echo "  --arch \"$(params.TF_ARCH)\" \\"
        echo "  --git-url \"$(params.TF_GIT_URL)\" \\"
        echo "  --git-ref \"$(params.TF_GIT_REF)\" \\"
        echo "  --path \"$(params.TF_PATH)\" \\"
        echo "  --plan \"$(params.TF_PLAN)\" \\"
        echo "  --timeout \"$(params.TF_TIMEOUT_MIN)\" \\"
        echo "  --no-wait \\"
        for arg in "${TEST_ENV_ARGS[@]}"; do
          echo "  $arg \\"
        done
        for arg in "${TMT_ENV_ARGS[@]}"; do
          echo "  $arg"
        done
        echo ""

        # Submit request (with --no-wait to get ID immediately without waiting)
        REQ_OUTPUT=$(testing-farm request \
          --compose "$(params.TF_COMPOSE)" \
          --arch "$(params.TF_ARCH)" \
          --git-url "$(params.TF_GIT_URL)" \
          --git-ref "$(params.TF_GIT_REF)" \
          --path "$(params.TF_PATH)" \
          --plan "$(params.TF_PLAN)" \
          --timeout "$(params.TF_TIMEOUT_MIN)" \
          --no-wait \
          "${TEST_ENV_ARGS[@]}" \
          "${TMT_ENV_ARGS[@]}" 2>&1)

        echo ""
        echo "==> Request Output:"
        echo "$REQ_OUTPUT"
        echo ""

        # Extract request ID from the "api" line
        # Format: ðŸ”Ž api https://api.dev.testing-farm.io/v0.1/requests/REQUEST-ID
        REQ_ID=$(echo "$REQ_OUTPUT" | grep -oP 'requests/\K[a-f0-9-]+' | head -1)
        echo "==> Extracted Request ID: '${REQ_ID}'"

        if [[ -z "${REQ_ID:-}" ]]; then
          echo "ERROR: Unable to extract Testing Farm request id"
          echo "Full output was:"
          echo "$REQ_OUTPUT"
          exit 2
        fi

        # Construct URLs
        API_URL="https://api.dev.testing-farm.io/v0.1/requests/${REQ_ID}"
        ARTIFACTS_URL="https://artifacts.dev.testing-farm.io/${REQ_ID}"

        echo ""
        echo ">> Request ID: $REQ_ID"
        echo ">> API URL: $API_URL"
        echo ">> Artifacts URL: $ARTIFACTS_URL"

        # Write request ID and artifacts URL to results immediately
        echo -n "${REQ_ID}" | tee "$(results.REQUEST_ID.path)"
        echo -n "${ARTIFACTS_URL}" | tee "$(results.ARTIFACTS_URL.path)"

        # Write placeholder for TEST_LOG_URL (will be updated after test completion)
        echo -n "${ARTIFACTS_URL}/results.xml" | tee "$(results.TEST_LOG_URL.path)"

        # Function to generate TEST_OUTPUT JSON
        generate_test_output() {
          local result="$1"
          local note="$2"

          local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          cat <<EOF
        {
          "result": "${result}",
          "timestamp": "${timestamp}",
          "note": "${note}"
        }
        EOF
        }

        echo ">> Waiting for completion (timeout: $(params.TF_TIMEOUT_MIN) min)"
        TIMEOUT_SECONDS=$(( ( $(params.TF_TIMEOUT_MIN) + 10 ) * 60 ))
        DEADLINE=$(( $(date +%s) + TIMEOUT_SECONDS ))

        # Poll every 30s;
        while true; do
          OUT=$(testing-farm list --id "$REQ_ID" --format json || true)
          STATE=$(echo "$OUT" | jq -r '.[0].state // empty')
          RESULT=$(echo "$OUT" | jq -r '.[0].result.overall // .[0].result // empty')

          echo "Current: state=${STATE:-?} result=${RESULT:-?}"

          # Check if request reached a terminal state
          if [[ "$STATE" == "complete" ]]; then
            echo ">> Test completed, attempting to fetch detailed results..."

            # Extract TEST_LOG_URL from results.xml now that test is complete
            # Use retry logic to handle race conditions and network issues
            echo ">> Extracting test log URL from results.xml..."
            MAX_RETRIES_FINAL=5
            RETRY_DELAY_FINAL=2
            RESULTS_XML_FINAL=""

            for attempt in $(seq 1 $MAX_RETRIES_FINAL); do
              echo ">> Attempt $attempt/$MAX_RETRIES_FINAL to fetch results.xml after completion..."
              RESULTS_XML_FINAL=$(curl -s -f "${ARTIFACTS_URL}/results.xml" 2>/dev/null || echo "")

              if [[ -n "${RESULTS_XML_FINAL}" ]]; then
                echo ">> results.xml fetched successfully after completion"
                break
              fi

              if [[ $attempt -lt $MAX_RETRIES_FINAL ]]; then
                echo ">> results.xml not yet available, waiting ${RETRY_DELAY_FINAL}s before retry..."
                sleep $RETRY_DELAY_FINAL
              fi
            done

            if [[ -n "${RESULTS_XML_FINAL}" ]]; then
              # Extract URL in two steps to handle any attribute order
              # Step 1: Find the line with name="testout.log"
              # Step 2: Extract href value from that line
              TEST_LOG_URL_FINAL=$(echo "${RESULTS_XML_FINAL}" | grep 'name="testout\.log"' | grep -oP 'href="\K[^"]+' | head -1 || echo "")
              if [[ -n "${TEST_LOG_URL_FINAL}" ]]; then
                echo ">> Test log URL found: ${TEST_LOG_URL_FINAL}"
                echo -n "${TEST_LOG_URL_FINAL}" | tee "$(results.TEST_LOG_URL.path)"
              else
                echo ">> Could not extract test log URL from results.xml, keeping placeholder"
              fi
            else
              echo ">> Could not fetch results.xml after $MAX_RETRIES_FINAL attempts, keeping placeholder"
            fi

            # Write TEST_SUMMARY with link to complete log
            if [[ -n "${TEST_LOG_URL_FINAL}" ]]; then
              echo "Complete test output available at: ${TEST_LOG_URL_FINAL}" | tee "$(results.TEST_SUMMARY.path)"
            else
              echo "Test artifacts available at: ${ARTIFACTS_URL}" | tee "$(results.TEST_SUMMARY.path)"
            fi

            if [[ "$RESULT" == "passed" ]]; then
              echo ">> PASSED"
              NOTE="Testing Farm request ${REQ_ID} completed successfully. Tests passed. Artifacts: ${ARTIFACTS_URL}"
              TEST_OUTPUT=$(generate_test_output "SUCCESS" "$NOTE")
              echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
              exit 0
            else
              echo ">> FAILED"
              testing-farm list --id "$REQ_ID" --format text || true
              NOTE="Testing Farm request ${REQ_ID} failed. Tests failed. Check artifacts: ${ARTIFACTS_URL}"
              TEST_OUTPUT=$(generate_test_output "FAILURE" "$NOTE")
              echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
              exit 1
            fi
          elif [[ "$STATE" == "error" ]]; then
            echo ">> ERROR: Infrastructure error occurred"
            testing-farm list --id "$REQ_ID" --format text || true
            NOTE="Testing Farm request ${REQ_ID} encountered an infrastructure error. Check artifacts: ${ARTIFACTS_URL}"
            echo "Infrastructure error - no test results available" | tee "$(results.TEST_SUMMARY.path)"
            TEST_OUTPUT=$(generate_test_output "ERROR" "$NOTE")
            echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
            exit 2
          elif [[ "$STATE" == "canceled" ]]; then
            echo ">> CANCELED: Request was canceled"
            testing-farm list --id "$REQ_ID" --format text || true
            NOTE="Testing Farm request ${REQ_ID} was canceled. Check artifacts: ${ARTIFACTS_URL}"
            echo "Request canceled - no test results available" | tee "$(results.TEST_SUMMARY.path)"
            TEST_OUTPUT=$(generate_test_output "ERROR" "$NOTE")
            echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
            exit 3
          fi

          # Check for timeout
          if (( $(date +%s) > DEADLINE )); then
            echo ">> TIMEOUT after $(params.TF_TIMEOUT_MIN) minutes"
            testing-farm list --id "$REQ_ID" --format text || true
            NOTE="Testing Farm request ${REQ_ID} timed out after $(params.TF_TIMEOUT_MIN) minutes. Check artifacts: ${ARTIFACTS_URL}"
            echo "Request timed out - no test results available" | tee "$(results.TEST_SUMMARY.path)"
            TEST_OUTPUT=$(generate_test_output "ERROR" "$NOTE")
            echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
            exit 4
          fi

          sleep 30
        done
